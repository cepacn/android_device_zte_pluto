project hardware/libhardware_legacy/
diff --git a/audio/AudioPolicyManagerBase.cpp b/audio/AudioPolicyManagerBase.cpp
index bb19830..f728723 100644
--- a/hardware/libhardware_legacy/audio/AudioPolicyManagerBase.cpp
+++ b/hardware/libhardware_legacy/audio/AudioPolicyManagerBase.cpp
@@ -1613,7 +1613,7 @@ AudioPolicyManagerBase::AudioPolicyManagerBase(AudioPolicyClientInterface *clien
     mLimitRingtoneVolume(false), mLastVoiceVolume(-1.0f),
     mTotalEffectsCpuLoad(0), mTotalEffectsMemory(0),
     mA2dpSuspended(false), mHasA2dp(false), mHasUsb(false), mHasRemoteSubmix(false),
-    mSpeakerDrcEnabled(false)
+    mSpeakerDrcEnabled(false),mBootRing(true)
 {
     mpClientInterface = clientInterface;
 
@@ -1649,9 +1649,29 @@ AudioPolicyManagerBase::AudioPolicyManagerBase(AudioPolicyClientInterface *clien
         {
             const IOProfile *outProfile = mHwModules[i]->mOutputProfiles[j];
 
-            if ((outProfile->mSupportedDevices & mAttachedOutputDevices) &&
-                    ((outProfile->mFlags & AUDIO_OUTPUT_FLAG_DIRECT) == 0)) {
+            if ((outProfile->mSupportedDevices & mAttachedOutputDevices) /*&&
+                    ((outProfile->mFlags & AUDIO_OUTPUT_FLAG_DIRECT) == 0)*/) {
                 AudioOutputDescriptor *outputDesc = new AudioOutputDescriptor(outProfile);
+                if(mBootRing == true ) {
+                       FILE *fp = NULL;
+                       int headset_state = 0;
+                       fp = fopen("/sys/class/switch/h2w/state","rb");
+                       if (NULL == fp){
+                               LOGV("getDeviceForStrategy() can't open file to read the state of headset");
+                       }else {
+                               fscanf(fp, "%d", &headset_state);
+                               LOGV("getDeviceForStrategy() read the state of headset %d",headset_state);
+                               fclose(fp);
+                       }
+                               if(1 == headset_state){
+                                       mDefaultOutputDevice = AUDIO_DEVICE_OUT_WIRED_HEADSET;
+                               }
+                               if(2 == headset_state){
+                                       mDefaultOutputDevice = AUDIO_DEVICE_OUT_WIRED_HEADPHONE;
+                               }
+                               mAvailableOutputDevices = (audio_devices_t) (mAvailableOutputDevices |
+                                                               (outProfile->mSupportedDevices & mDefaultOutputDevice));
+                }
                 outputDesc->mDevice = (audio_devices_t)(mDefaultOutputDevice &
                                                             outProfile->mSupportedDevices);
                 audio_io_handle_t output = mpClientInterface->openOutput(
@@ -1681,6 +1701,8 @@ AudioPolicyManagerBase::AudioPolicyManagerBase(AudioPolicyClientInterface *clien
         }
     }
 
+    mBootRing = false;
+
     ALOGE_IF((mAttachedOutputDevices & ~mAvailableOutputDevices),
              "Not output found for attached devices %08x",
              (mAttachedOutputDevices & ~mAvailableOutputDevices));
@@ -1949,6 +1971,13 @@ status_t AudioPolicyManagerBase::checkOutputsForDevice(audio_devices_t device,
                 continue;
             }
 
+            if (profile->mSamplingRates[0] !=0
+               && profile->mFormats[0] !=0
+               && profile->mChannelMasks[0] != 0
+               && (profile->mFlags & AUDIO_OUTPUT_FLAG_DIRECT)) {
+               continue;
+            }
+
             ALOGV("opening output for device %08x", device);
             desc = new AudioOutputDescriptor(profile);
             desc->mDevice = device;
@@ -2796,6 +2825,31 @@ audio_devices_t AudioPolicyManagerBase::getDeviceForInputSource(int inputSource)
 {
     uint32_t device = AUDIO_DEVICE_NONE;
 
+    if (((mAvailableOutputDevices &  AUDIO_DEVICE_OUT_WIRED_HEADSET)  && 
+               !(mAvailableInputDevices & AUDIO_DEVICE_IN_WIRED_HEADSET)) ||
+               (!(mAvailableOutputDevices & AUDIO_DEVICE_OUT_WIRED_HEADSET) && 
+                       (mAvailableInputDevices & AUDIO_DEVICE_IN_WIRED_HEADSET))){
+       FILE *fp = NULL;
+       int headset_state = 0;
+       fp = fopen("/sys/class/switch/h2w/starts","rb");
+       if (NULL == fp) {
+               ALOGV("getDeviceForInputSource() can't open file to read the state of headset");
+       }else {
+               fscanf(fp, "%d",&headset_state);
+               ALOGV("getDeviceForInputSource() read the state of headset is %d",headset_state);
+               fclose(fp);
+       }
+       if(1 == headset_state){
+               if(!(mAvailableInputDevices & AUDIO_DEVICE_IN_WIRED_HEADSET)){
+                       mAvailableInputDevices = (audio_devices_t)(mAvailableInputDevices | AUDIO_DEVICE_IN_WIRED_HEADSET);
+               }
+               }else if (0 == headset_state) {
+                       if (mAvailableInputDevices & AUDIO_DEVICE_IN_WIRED_HEADSET){
+                               mAvailableInputDevices = (audio_devices_t)(mAvailableInputDevices & ~ AUDIO_DEVICE_IN_WIRED_HEADSET);
+                       }
+               }
+       }
+
     switch (inputSource) {
     case AUDIO_SOURCE_VOICE_UPLINK:
       if (mAvailableInputDevices & AUDIO_DEVICE_IN_VOICE_CALL) {

